# 1.删除链表中重复的结点
## 题目
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

# 2.从尾到头打印链表
## 题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking

# 3.在 O(1) 时间内删除链表节点（4.4）
## 解题思路
  ① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。
  ② 如果链表只有一个节点，那么直接返回null
  ③ 如果链表不止一个节点，那么从头遍历找到该节点的上一个节点
 
 综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。
 
 # 4.判断链表有无环（4.8）
 
 # 5.判断链表有无环并找出环的入口（4.8）
  /*
 * 判断是否存在环，如果存在，则找出环的入口点。
 * 入口点找法：快慢指针，块指针走两步，满指针走一步，如果存在循环，则在慢指针走完环前，总会和快指针相遇。
 * 从头指针和相遇点同时向后走，相遇的点必定是入口点。
 * */
# 6.寻找两个链表的交点(4.8)
  找到两个单链表相交的起始节点。
    •如果两个链表没有交点，返回 null.
    •在返回结果后，两个链表仍须保持原有的结构。
    •可假定整个链表结构中没有循环。
    •程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

# 7.寻找两个链表的交点(4.9)
  说明：要考虑所遇的可能，两个链表都可能有环，也可能无环，要分情况讨论判断

# 8.链表中倒数第 K 个结点（4.11）
  设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。  
此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节

# 9.反转链表
   输入一个链表，反转链表后，输出新链表的表头。(ReverseList.java)
# 10.合并两个排序的链表
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则