# 1.冒泡排序算法（4.2）
## 算法思想：
它重复地访问要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。直到没有再需要交换，则排序完成。（稳定排序）


# 2.选择排序（Selection Sort）（4.3）
## 算法思想：
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，直到所有元素均排序完毕。 （不稳定排序）

# 3.插入排序
## 算法思想
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（稳定排序）
## 算法分析
表现最稳定的排序算法之一，因为无论什么数据都是O(n2)的时间复杂度

# 4.希尔排序
## 算法思想
希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。
## 注意：  
在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，不用循环按组处理，我们可以从第gap个元素开始，逐个跨组处理。同时，在插入数据时，可以采用元素交换法寻找最终位置，也可以采用数组元素移动法寻觅。

# 5.归并排序（Merge Sort）(5.7)
 算法是采用分治法（Divide and Conquer）。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，称为2-路归并。 
## 算法描述
（1）把长度为n的输入序列分成两个长度为n/2的子序列；  
（2）对这两个子序列分别采用归并排序；  
（3）将两个排序好的子序列合并成一个最终的排序序列。  
## 算法分析
归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

# 6.快速排序（5.7）
## 算法思想
通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

# 7.堆排序（5.7）
## 堆定义
堆是具有下列性质的完全二叉树：  
每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
## 算法思想  
将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走(将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次最大值。如此反复执行，就能得到一个有序序列了。